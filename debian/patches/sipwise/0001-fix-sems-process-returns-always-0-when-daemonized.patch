From 770055e4a9593a3fa193ed1a763c1df592b8ea92 Mon Sep 17 00:00:00 2001
From: Victor Seva <linuxmaniac@torreviejawireless.org>
Date: Wed, 22 May 2013 12:08:42 +0200
Subject: [PATCH] fix: sems process returns always 0 when daemonized.

https://bugtracker.iptel.org/view.php?id=63
https://bugtracker.sipwise.com/view.php?id=779
---
 core/sems.cpp |   46 +++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 43 insertions(+), 3 deletions(-)

diff --git a/core/sems.cpp b/core/sems.cpp
index d34e04a..a8a81a9 100644
--- a/core/sems.cpp
+++ b/core/sems.cpp
@@ -285,6 +285,9 @@ int main(int argc, char* argv[])
 {
   int success = false;
   std::map<char,string> args;
+  #ifndef DISABLE_DAEMON_MODE
+  int fd[2] = {0,0};
+  #endif
 
   progname = strrchr(argv[0], '/');
   progname = (progname == NULL ? argv[0] : progname + 1);
@@ -362,7 +365,6 @@ int main(int argc, char* argv[])
   AmConfig::dump_Ifs();
 
 #ifndef DISABLE_DAEMON_MODE
-
   if(AmConfig::DaemonMode){
     if(!AmConfig::DaemonGid.empty()){
       unsigned int gid;
@@ -407,13 +409,36 @@ int main(int argc, char* argv[])
     }
 
     /* fork to become!= group leader*/
+    if (pipe(fd) == -1) { /* Create a pipe */
+        ERROR("Cannot create pipe.\n");
+        goto error;
+    }
     int pid;
     if ((pid=fork())<0){
       ERROR("Cannot fork: %s.\n", strerror(errno));
       goto error;
     }else if (pid!=0){
-      /* parent process => exit*/
+      close(fd[1]);
+      /* parent process => wait for result from child*/
+      for(int i=0;i<2;i++){
+        INFO("waiting for child[%d] response\n", i);
+        read(fd[0], &pid, sizeof(int));
+        if(pid<0){
+          ERROR("Child [%d] return an error: %d\n", i, pid);
+          close(fd[0]);
+          goto error;
+        }
+        INFO("child [%d] pid:%d\n", i, pid);
+      }
+      INFO("all childs return OK. bye world!\n");
+      close(fd[0]);
       return 0;
+    }else {
+      /* child */
+      close(fd[0]);
+      main_pid = getpid();
+      INFO("hi world! I'm child [%d]\n", main_pid);
+      write(fd[1], &main_pid, sizeof(int));
     }
     /* become session leader to drop the ctrl. terminal */
     if (setsid()<0){
@@ -425,6 +450,9 @@ int main(int argc, char* argv[])
       goto error;
     }else if (pid!=0){
       /*parent process => exit */
+      close(fd[1]);
+      main_pid = getpid();
+      INFO("I'm out. pid: %d", main_pid);
       return 0;
     }
 	
@@ -488,7 +516,13 @@ int main(int argc, char* argv[])
 
   INFO("Starting SIP stack (control interface)\n");
   sip_ctrl.load();
-  
+
+  #ifndef DISABLE_DAEMON_MODE
+  INFO("hi world! I'm main child [%d]\n", main_pid);
+  write(fd[1], &main_pid, sizeof(int));
+  close(fd[1]);
+  #endif
+
   if(sip_ctrl.run() != -1)
     success = true;
 
@@ -513,6 +547,12 @@ int main(int argc, char* argv[])
   if (AmConfig::DaemonMode) {
     unlink(AmConfig::DaemonPidFile.c_str());
   }
+  if (!(fcntl(fd[1], F_GETFL) == -1 && errno == EBADF)){
+    main_pid = -1;
+    ERROR("send -1 to parent\n");
+    write(fd[1], &main_pid, sizeof(int));
+    close(fd[1]);
+  }
 #endif
 
   sip_ctrl.cleanup();
-- 
1.7.10.4

