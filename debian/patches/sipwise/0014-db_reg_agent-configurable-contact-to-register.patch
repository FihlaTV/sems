From 3454e5fa938a7aa7c1a5ce68416eb6651d8f2bce Mon Sep 17 00:00:00 2001
From: Stefan Sayer <stefan.sayer@googlemail.com>
Date: Sat, 28 May 2011 16:32:10 +0200
Subject: [PATCH] db_reg_agent: configurable contact to register

- override hostport portion
- set per-subscription contact
---
 apps/db_reg_agent/DBRegAgent.cpp        |   62 ++++++++++++++++++++++++-------
 apps/db_reg_agent/DBRegAgent.h          |   15 ++++++--
 apps/db_reg_agent/etc/db_reg_agent.conf |   17 ++++++++-
 doc/Readme.db_reg_agent.txt             |   38 ++++++++++++++-----
 4 files changed, 103 insertions(+), 29 deletions(-)

diff --git a/apps/db_reg_agent/DBRegAgent.cpp b/apps/db_reg_agent/DBRegAgent.cpp
index 51007e0..4402ff6 100644
--- a/apps/db_reg_agent/DBRegAgent.cpp
+++ b/apps/db_reg_agent/DBRegAgent.cpp
@@ -48,6 +48,8 @@ unsigned int DBRegAgent::ratelimit_per = 0;
 
 bool DBRegAgent::delete_removed_registrations = true;
 bool DBRegAgent::save_contacts = true;
+bool DBRegAgent::db_read_contact = false;
+string DBRegAgent::contact_hostport;
 
 unsigned int DBRegAgent::error_retry_interval = 300;
 
@@ -132,6 +134,11 @@ int DBRegAgent::onLoad()
   save_contacts =
     cfg.getParameter("save_contacts", "yes") == "yes";
 
+  db_read_contact =
+    cfg.getParameter("db_read_contact", "no") == "yes";
+
+  contact_hostport = cfg.getParameter("contact_hostport");
+
   error_retry_interval = cfg.getParameterInt("error_retry_interval", 300);
   if (!error_retry_interval) {
     WARN("disabled retry on errors!\n");
@@ -241,6 +248,11 @@ bool DBRegAgent::loadRegistrations() {
       int status = 0; 
       long subscriber_id = row[COLNAME_SUBSCRIBER_ID];
 
+      string contact_uri;
+      if (db_read_contact && row[COLNAME_CONTACT] != mysqlpp::null) {
+	contact_uri = (string) row[COLNAME_CONTACT];
+      }
+
       if (row[COLNAME_STATUS] != mysqlpp::null)
 	status = row[COLNAME_STATUS];
       else {
@@ -261,7 +273,8 @@ bool DBRegAgent::loadRegistrations() {
 	  createRegistration(subscriber_id,
 			     (string)row[COLNAME_USER],
 			     (string)row[COLNAME_PASS],
-			     (string)row[COLNAME_REALM]
+			     (string)row[COLNAME_REALM],
+			     contact_uri
 			     );
 	  scheduleRegistration(subscriber_id);
 	}; break;
@@ -271,7 +284,8 @@ bool DBRegAgent::loadRegistrations() {
 	  createRegistration(subscriber_id,
 			     (string)row[COLNAME_USER],
 			     (string)row[COLNAME_PASS],
-			     (string)row[COLNAME_REALM]
+			     (string)row[COLNAME_REALM],
+			     contact_uri
 			     );
 
 	  time_t dt_expiry = now_time;
@@ -325,14 +339,21 @@ bool DBRegAgent::loadRegistrations() {
 void DBRegAgent::createRegistration(long subscriber_id,
 				    const string& user,
 				    const string& pass,
-				    const string& realm) {
+				    const string& realm,
+				    const string& contact) {
+
+  string contact_uri = contact;
+  if (contact_uri.empty() && !contact_hostport.empty()) {
+    contact_uri = "sip:"+ user + "@" + contact_hostport;
+  }
+
   string handle = AmSession::getNewId();
   SIPRegistrationInfo reg_info(realm, user,
 			       user, // name
 			       user, // auth_user
 			       pass,
 			       "", // proxy
-			       "" // contact
+			       contact_uri // contact
 			       );
 
   registrations_mut.lock();
@@ -392,7 +413,8 @@ void DBRegAgent::createRegistration(long subscriber_id,
 void DBRegAgent::updateRegistration(long subscriber_id,
 				    const string& user,
 				    const string& pass,
-				    const string& realm) {
+				    const string& realm,
+				    const string& contact) {
 
   registrations_mut.lock();
   map<long, AmSIPRegistration*>::iterator it=registrations.find(subscriber_id);
@@ -400,7 +422,7 @@ void DBRegAgent::updateRegistration(long subscriber_id,
     registrations_mut.unlock();
     WARN("updateRegistration - registration %ld %s@%s unknown, creating\n",
 	 subscriber_id, user.c_str(), realm.c_str());
-    createRegistration(subscriber_id, user, pass, realm);
+    createRegistration(subscriber_id, user, pass, realm, contact);
     scheduleRegistration(subscriber_id);
     return;
   }
@@ -410,7 +432,7 @@ void DBRegAgent::updateRegistration(long subscriber_id,
 						      user, // auth_user
 						      pass,
 						      "",   // proxy
-						      "")); // contact
+						      contact)); // contact
   registrations_mut.unlock();
 }
 
@@ -921,12 +943,13 @@ void DBRegAgent::timer_cb(RegTimer* timer, long subscriber_id, int reg_action) {
 
 void DBRegAgent::DIcreateRegistration(int subscriber_id, const string& user, 
 				      const string& pass, const string& realm,
+				      const string& contact,
 				      AmArg& ret) {
-  DBG("DI method: createRegistration(%i, %s, %s, %s)\n",
+  DBG("DI method: createRegistration(%i, %s, %s, %s, %s)\n",
       subscriber_id, user.c_str(),
-      pass.c_str(), realm.c_str());
+      pass.c_str(), realm.c_str(), contact.c_str());
 
-  createRegistration(subscriber_id, user, pass, realm);
+  createRegistration(subscriber_id, user, pass, realm, contact);
   scheduleRegistration(subscriber_id);
   ret.push(200);
   ret.push("OK");
@@ -934,11 +957,12 @@ void DBRegAgent::DIcreateRegistration(int subscriber_id, const string& user,
 
 void DBRegAgent::DIupdateRegistration(int subscriber_id, const string& user, 
 				      const string& pass, const string& realm,
+				      const string& contact,
 				      AmArg& ret) {
   DBG("DI method: updateRegistration(%i, %s, %s, %s)\n",
       subscriber_id, user.c_str(),
       pass.c_str(), realm.c_str());
-  updateRegistration(subscriber_id, user, pass, realm);
+  updateRegistration(subscriber_id, user, pass, realm, contact);
   ret.push(200);
   ret.push("OK");
 }
@@ -963,14 +987,24 @@ void DBRegAgent::invoke(const string& method,
 {
   if (method == "createRegistration"){
     args.assertArrayFmt("isss"); // subscriber_id, user, pass, realm
+    string contact;
+    if (args.size() > 4) {
+      assertArgCStr(args.get(4));
+      contact = args.get(4).asCStr();
+    }
     DIcreateRegistration(args.get(0).asInt(), args.get(1).asCStr(), 
 			 args.get(2).asCStr(),args.get(3).asCStr(),
-			 ret);
+			 contact, ret);
   } else if (method == "updateRegistration"){
     args.assertArrayFmt("isss"); // subscriber_id, user, pass, realm
-    DIupdateRegistration(args.get(0).asInt(), args.get(1).asCStr(), 
+    string contact;
+    if (args.size() > 4) {
+      assertArgCStr(args.get(4));
+      contact = args.get(4).asCStr();
+    }
+    DIupdateRegistration(args.get(0).asInt(), args.get(1).asCStr(),
 			 args.get(2).asCStr(),args.get(3).asCStr(),
-			 ret);
+			 contact, ret);
   } else if (method == "removeRegistration"){
     args.assertArrayFmt("i"); // subscriber_id
     DIremoveRegistration(args.get(0).asInt(), ret);
diff --git a/apps/db_reg_agent/DBRegAgent.h b/apps/db_reg_agent/DBRegAgent.h
index 8ea7a00..2494c4d 100644
--- a/apps/db_reg_agent/DBRegAgent.h
+++ b/apps/db_reg_agent/DBRegAgent.h
@@ -56,6 +56,7 @@ using std::queue;
 #define COLNAME_USER             "user"
 #define COLNAME_PASS             "pass"
 #define COLNAME_REALM            "realm"
+#define COLNAME_CONTACT          "contact"
 
 #define COLNAME_STATUS           "registration_status"
 #define COLNAME_EXPIRY           "expiry"
@@ -127,6 +128,10 @@ class DBRegAgent
   static bool delete_removed_registrations;
   static bool save_contacts;
 
+  static bool db_read_contact;
+
+  static string contact_hostport;
+
   static unsigned int error_retry_interval;
 
   map<long, AmSIPRegistration*> registrations;
@@ -160,12 +165,14 @@ class DBRegAgent
   void createRegistration(long subscriber_id,
 			  const string& user,
 			  const string& pass,
-			  const string& realm);
+			  const string& realm,
+			  const string& contact);
   /** update registration in our list */
   void updateRegistration(long subscriber_id,
 			  const string& user,
 			  const string& pass,
-			  const string& realm);
+			  const string& realm,
+			  const string& contact);
 
   /** remove registration */
   void removeRegistration(long subscriber_id);
@@ -215,10 +222,10 @@ class DBRegAgent
 
   void DIcreateRegistration(int subscriber_id, const string& user, 
 			    const string& pass, const string& realm,
-			    AmArg& ret);
+			    const string& contact, AmArg& ret);
   void DIupdateRegistration(int subscriber_id, const string& user, 
 			    const string& pass, const string& realm,
-			    AmArg& ret);
+			    const string& contact, AmArg& ret);
   void DIremoveRegistration(int subscriber_id, AmArg& ret);
 
 
diff --git a/apps/db_reg_agent/etc/db_reg_agent.conf b/apps/db_reg_agent/etc/db_reg_agent.conf
index fcd6f26..2e1f5ca 100644
--- a/apps/db_reg_agent/etc/db_reg_agent.conf
+++ b/apps/db_reg_agent/etc/db_reg_agent.conf
@@ -16,9 +16,22 @@ mysql_passwd=mypass123
 # (without trailing ';' such that where clause can appended)
 joined_query="select subscribers.subscriber_id as subscriber_id, subscribers.user as user, subscribers.pass as pass, subscribers.realm as realm, registrations.registration_status as registration_status, registrations.expiry as expiry, registrations.last_registration as last_registration from subscribers left join registrations on subscribers.subscriber_id=registrations.subscriber_id"
 
+#example with contact:
+# joined_query="select subscribers.subscriber_id as subscriber_id, subscribers.user as user, subscribers.pass as pass, subscribers.realm as realm, subscribers.contact as contact, registrations.registration_status as registration_status, registrations.expiry as expiry, registrations.last_registration as last_registration from subscribers left join registrations on subscribers.subscriber_id=registrations.subscriber_id"
+
+# contact_hostport=<host:port> - overriding contact host:port
+# sets the contact host:port portion that is registered
+# default: empty
+#contact_hostport=10.0.0.50:5080
+
+# db_read_contact=[yes, no] : read individual contact to register from DB?
+# note: joined_query must select the contact, too
+# default: no
+#db_read_contact=yes
+
 #save_contacts=[yes, no] : save contacts?
-# for troubleshooting, all contacts returned with a positive reply may be saved
-# to DB in the registrations.contacts colums
+# for monitoring and troubleshooting, all contacts returned with a positive reply
+# may be saved to DB in the registrations.contacts colums
 # default: yes
 #save_contacts=yes
 
diff --git a/doc/Readme.db_reg_agent.txt b/doc/Readme.db_reg_agent.txt
index 0eebe81..b4a7b54 100644
--- a/doc/Readme.db_reg_agent.txt
+++ b/doc/Readme.db_reg_agent.txt
@@ -17,6 +17,8 @@ pick up the new registration.
 Features
 - configurable subscription query
 - configurable desired expires
+- configurable contact: global hostport setting, or per registration
+- monitoring of registration status and contacts through DB
 - flatten out re-register spikes by intelligently planning registration refresh
 - ratelimiting (x new REGISTER requests per y seconds)
 - seamless restart of SEMS server possible; registration status is restored from DB.
@@ -24,32 +26,49 @@ Features
 DI control functions
 --------------------
 
- createRegistration(int subscriber_id, string user, string pass, string realm)
- updateRegistration(int subscriber_id, string user, string pass, string realm)
+ createRegistration(int subscriber_id, string user, string pass, string realm [, string contact])
+ updateRegistration(int subscriber_id, string user, string pass, string realm [, string contact])
  removeRegistration(int subscriber_id)
 
 After removing a registration by issuing removeRegistration, the subcriber entry will
 be present with the status REMOVED. 
 
-Registration status (registration_status)
------------------------------------------
+Registration status (registration_status column)
+------------------------------------------------
  REG_STATUS_INACTIVE      0
  REG_STATUS_PENDING       1
  REG_STATUS_ACTIVE        2
  REG_STATUS_FAILED        3
  REG_STATUS_REMOVED       4
 
+Configuring contact
+-------------------
+By default the contact is constructed of sip:<user>@<public_ip/sip_ip:port> .
+
+In some settings it may be desirable to control the Contact that is registered. The
+contact_hostport setting overrides the host:port part. Per-registration contact can be
+specified by setting option db_read_contact=yes and providing a contact in the
+subscriber.contact column, and passing it with createRegistration/updateRegistration DI
+function.
+
 Database 
 --------
-There may be two tables, subscriptions and registration status. The query which
-selects subscription and registration status as join may be configured as well
-as the name of the registration status table (registrations_table).
+There may be two separate tables, subscriptions and registrations (status). SEMS inserts
+and updates entries only in the registrations table, where the last registration status
+is kept, both for monitoring purposes, and to enable seamless server restart or failover.
+
+The query which selects subscription and registration status as join may be configured
+as well as the name of the registration status table (registrations_table). By pointing
+to the same table, they can be configured to use only one database table.
 
 Clocks of SEMS host and DB host must be synchronized in order for restart without
 massive re-registration to work.
 
-Example tables structure (note that registrations.contacts is not necessary if
-save_contacts=no):
+Example tables structure below.
+
+Optional fields
+ - registrations.contacts depending on save_contacts option
+ - subscriber.contact depending on db_read_contact option
 
 CREATE TABLE IF NOT EXISTS `registrations` (
   `subscriber_id` int(11) NOT NULL,
@@ -67,6 +86,7 @@ CREATE TABLE IF NOT EXISTS `subscribers` (
   `user` varchar(256) CHARACTER SET ascii COLLATE ascii_bin NOT NULL,
   `pass` varchar(256) CHARACTER SET ascii COLLATE ascii_bin NOT NULL,
   `realm` varchar(256) CHARACTER SET ascii COLLATE ascii_bin NOT NULL,
+  `contact` varchar(256) CHARACTER SET ascii COLLATE ascii_bin NOT NULL,
   PRIMARY KEY (`subscriber_id`)
 ) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=2 ;
 
-- 
1.7.10.4

