From dfe58a0cb1c6547b7d237d1603a39b645a74cbbd Mon Sep 17 00:00:00 2001
From: Stefan Sayer <stefan.sayer@frafos.com>
Date: Thu, 13 Oct 2011 12:58:20 +0200
Subject: [PATCH] moved SipRegistration to AmSipRegistration in core

Conflicts:

	apps/registrar_client/SIPRegistrarClient.cpp
	apps/registrar_client/SIPRegistrarClient.h

Conflicts:

	apps/registrar_client/SIPRegistrarClient.cpp
	apps/registrar_client/SIPRegistrarClient.h
---
 apps/registrar_client/SIPRegistrarClient.cpp |  275 -------------------------
 apps/registrar_client/SIPRegistrarClient.h   |  124 +-----------
 core/AmSipRegistration.cpp                   |  278 ++++++++++++++++++++++++++
 core/AmSipRegistration.h                     |  158 +++++++++++++++
 4 files changed, 439 insertions(+), 396 deletions(-)
 create mode 100644 core/AmSipRegistration.cpp
 create mode 100644 core/AmSipRegistration.h

diff --git a/apps/registrar_client/SIPRegistrarClient.cpp b/apps/registrar_client/SIPRegistrarClient.cpp
index 1a1a666..b19f162 100644
--- a/apps/registrar_client/SIPRegistrarClient.cpp
+++ b/apps/registrar_client/SIPRegistrarClient.cpp
@@ -33,8 +33,6 @@
 
 #define MOD_NAME "registrar_client"
 
-#define REGISTER_SEND_TIMEOUT 60 
-
 #include <unistd.h>
 
 //EXPORT_SIP_EVENT_HANDLER_FACTORY(SIPRegistrarClient, MOD_NAME);
@@ -48,154 +46,6 @@ extern "C" void* plugin_class_create()
     return (AmPluginFactory*)reg_c;
 }
 
-
-SIPRegistration::SIPRegistration(const string& handle,
-				 const SIPRegistrationInfo& info,
-				 const string& sess_link) 
-  : info(info),
-    dlg(this),
-    cred(info.domain, info.auth_user, info.pwd),
-    active(false),
-    reg_begin(0),
-    reg_expires(0),
-    remove(false),
-    sess_link(sess_link),
-    reg_send_begin(0),
-    waiting_result(false),
-    seh(NULL)
-{
-  req.cmd      = "sems";
-  req.user     = info.user;
-  req.method   = "REGISTER";
-  req.r_uri    = "sip:"+info.domain;
-  req.from     = info.name+" <sip:"+info.user+"@"+info.domain+">";
-  req.from_uri = "sip:"+info.user+"@"+info.domain;
-  req.from_tag = handle;
-  req.to       = req.from;
-  req.to_tag   = "";
-  req.callid   = AmSession::getNewId(); 
-  //
-
-  // clear dlg.callid? ->reregister?
-  dlg.updateStatusFromLocalRequest(req);
-  dlg.cseq = 50;
-  if(!info.contact.empty()) {
-      dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<sip:";
-      dlg.contact_uri += info.contact + ">" + CRLF;
-  }
-}
-
-SIPRegistration::~SIPRegistration() {
-  setSessionEventHandler(NULL);
-}
-
-void SIPRegistration::setSessionEventHandler(AmSessionEventHandler* new_seh) {
-  if (seh)
-    delete seh;
-  seh = new_seh;
-}
- 
-void SIPRegistration::doRegistration() 
-{
-    waiting_result = true;
-    req.to_tag     = "";
-    dlg.remote_tag = "";
-    req.r_uri    = "sip:"+info.domain;
-    dlg.remote_uri = req.r_uri;
-    
-    // set outbound proxy as next hop 
-    if (!info.proxy.empty()) {
-	dlg.outbound_proxy = info.proxy;
-    } else if (!AmConfig::OutboundProxy.empty()) {
-	dlg.outbound_proxy = AmConfig::OutboundProxy;
-    }
-
-    if(!info.contact.empty()) {
-      dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<"
-        + info.contact + ">" + CRLF;
-    }
-    
-    if (dlg.sendRequest(req.method, "", "", "Expires: 3600\n") < 0)
-      ERROR("failed to send registration.\n");
-    
-    // save TS
-    struct timeval now;
-    gettimeofday(&now, NULL);
-    reg_send_begin  = now.tv_sec;
-}
-
-void SIPRegistration::doUnregister() 
-{
-    waiting_result = true;
-    req.to_tag     = "";
-    dlg.remote_tag = "";
-    req.r_uri      = "sip:"+info.domain;
-    dlg.remote_uri = req.r_uri;
-    
-    // set outbound proxy as next hop 
-    if (!info.proxy.empty()) {
-	dlg.outbound_proxy = info.proxy;
-    } else if (!AmConfig::OutboundProxy.empty()) 
-	dlg.outbound_proxy = AmConfig::OutboundProxy;
-    //else 
-    //    dlg.outbound_proxy = "";
-    if(!info.contact.empty()) {
-        dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<";
-        dlg.contact_uri += info.contact + ">" + CRLF;
-    }
-    
-    if (dlg.sendRequest(req.method, "", "", "Expires: 0\n") < 0)
-      ERROR("failed to send deregistration.\n");
-
-    // save TS
-    struct timeval now;
-    gettimeofday(&now, NULL);
-    reg_send_begin  = now.tv_sec;
-}
-
-void SIPRegistration::onSendRequest(const string& method,
-				    const string& content_type,
-				    const string& body,
-				    string& hdrs,
-				    int flags,
-				    unsigned int cseq) {
-  if (seh)
-    seh->onSendRequest(method, content_type, body,
-		       hdrs,flags,cseq);
-}
-	
-void SIPRegistration::onSendReply(const AmSipRequest& req,
-				  unsigned int  code,
-				  const string& reason,
-				  const string& content_type,
-				  const string& body,
-				  string& hdrs,
-				  int flags) {
-  if (seh)
-    seh->onSendReply(req,code,reason,
-		     content_type,body,hdrs,flags);
-}
-
-SIPRegistration::RegistrationState SIPRegistration::getState() {
-  if (active) 
-    return RegisterActive;
-  if (waiting_result)
-    return RegisterPending;
-	
-  return RegisterExpired;
-}
-
-unsigned int SIPRegistration::getExpiresLeft() {
-  struct timeval now;
-  gettimeofday(&now, NULL);
-	
-  int diff = reg_begin + reg_expires  - now.tv_sec;
-  if (diff < 0) 
-    return 0;
-  else 
-    return diff;
-}
-
 //-----------------------------------------------------------
 SIPRegistrarClient* SIPRegistrarClient::_instance=0;
 
@@ -241,31 +91,6 @@ void SIPRegistrarClient::run() {
     }
   }
 }
-	
-void SIPRegistration::onRegisterExpired() {
-  if (sess_link.length()) {
-    AmSessionContainer::instance()->postEvent(sess_link,
-					      new SIPRegistrationEvent(SIPRegistrationEvent::RegisterTimeout,
-								       req.from_tag));
-  }
-  DBG("Registration '%s' expired.\n", (info.user+"@"+info.domain).c_str());
-  active = false;
-  remove = true;
-}
-
-void SIPRegistration::onRegisterSendTimeout() {
-  if (sess_link.length()) {
-    AmSessionContainer::instance()->postEvent(sess_link,
-					      new SIPRegistrationEvent(SIPRegistrationEvent::RegisterSendTimeout,
-								       req.from_tag));
-  }
-  DBG("Registration '%s' REGISTER request timeout.\n", 
-      (info.user+"@"+info.domain).c_str());
-  active = false;
-  remove = true;
-}
-
-
 
 void SIPRegistrarClient::checkTimeouts() {
   //	DBG("checking timeouts...\n");
@@ -365,106 +190,6 @@ void SIPRegistrarClient::onSipReplyEvent(AmSipReplyEvent* ev) {
   }
 }
 
-bool SIPRegistration::registerSendTimeout(time_t now_sec) {
-  return now_sec > reg_send_begin + REGISTER_SEND_TIMEOUT;
-}
-
-bool SIPRegistration::timeToReregister(time_t now_sec) {
-  //   	if (active) 
-  //   		DBG("compare %lu with %lu\n",(reg_begin+reg_expires), (unsigned long)now_sec);
-  return (((unsigned long)reg_begin+ reg_expires/2) < (unsigned long)now_sec);	
-}
-
-bool SIPRegistration::registerExpired(time_t now_sec) {
-  return ((reg_begin+reg_expires) < (unsigned int)now_sec);	
-}
-
-void SIPRegistration::onSipReply(const AmSipReply& reply, int old_dlg_status, const string& trans_method)
-{
-  if ((seh!=NULL) && seh->onSipReply(reply, old_dlg_status, trans_method))
-    return;
-
-  waiting_result = false;
-
-  if ((reply.code>=200)&&(reply.code<300)) {
-    DBG("positive reply to REGISTER!\n");
-    size_t end  = 0;
-    string local_contact_hdr = dlg.getContactHdr();
-    local_contact.parse_contact(local_contact_hdr, (size_t)0, end);
-    local_contact.dump();
-
-    string contacts = reply.contact;
-    if (contacts.empty()) 
-      contacts = getHeader(reply.hdrs, "Contact", "m", true);
-    bool found = false;
-
-    if (!contacts.length()) {
-      DBG("received positive reply to de-Register \n");
-      active = false;
-      remove = true;
-    } else {
-      end = 0;
-      while (!found) {
-	if (contacts.length() == end)
-	  break;
-
-	if (!server_contact.parse_contact(contacts, end, end)) {
-	  ERROR("while parsing contact\n");
-	  break;
-	}
-	server_contact.dump();
-				
-	if (server_contact.isEqual(local_contact)) {
-	  DBG("contact found\n");
-	  found = active = true;
-	  //bool str2i(const string& str, unsigned int& result);
-					
-	  if (str2i(server_contact.params["expires"], reg_expires)) {
-	    ERROR("could not extract expires value.\n");
-	    reg_expires = 500;
-	  }
-	  DBG("got an expires of %d\n", reg_expires);
-	  // save TS
-	  struct timeval now;
-	  gettimeofday(&now, NULL);
-	  reg_begin = now.tv_sec;
-
-	  if (sess_link.length()) {
-	    DBG("posting SIPRegistrationEvent to '%s'\n", sess_link.c_str());
-	    AmSessionContainer::instance()->postEvent(sess_link,
-						      new SIPRegistrationEvent(SIPRegistrationEvent::RegisterSuccess,
-									       req.from_tag,
-									       reply.code, reply.reason));
-	  }
-	  break;
-	}
-      }
-    }
-    if (!found) {
-      if (sess_link.length()) {
-	AmSessionContainer::instance()->postEvent(sess_link,
-						  new SIPRegistrationEvent(SIPRegistrationEvent::RegisterNoContact,
-									   req.from_tag,
-									   reply.code, reply.reason));
-      }
-      DBG("no matching Contact - deregistered.\n");
-      active = false;
-      remove = true;
-    }
-		
-  } else if (reply.code >= 300) {
-    DBG("Registration failed.\n");
-    if (sess_link.length()) {
-      AmSessionContainer::instance()->postEvent(sess_link,
-						new SIPRegistrationEvent(SIPRegistrationEvent::RegisterFailed,
-									 req.from_tag,
-									 reply.code, reply.reason));
-    }
-    active = false;
-    remove = true;		
-  }
-}
-
 void SIPRegistrarClient::onNewRegistration(SIPNewRegistrationEvent* new_reg) {
 
   SIPRegistration* reg = new SIPRegistration(new_reg->handle, new_reg->info, 
diff --git a/apps/registrar_client/SIPRegistrarClient.h b/apps/registrar_client/SIPRegistrarClient.h
index 0d67c7d..d054565 100644
--- a/apps/registrar_client/SIPRegistrarClient.h
+++ b/apps/registrar_client/SIPRegistrarClient.h
@@ -28,12 +28,8 @@
 #ifndef RegisterClient_h
 #define RegisterClient_h
 
+#include "AmSipRegistration.h"
 #include "AmApi.h"
-#include "AmSession.h"
-#include "ContactInfo.h"
-
-#include "ampi/SIPRegistrarClientAPI.h"
-#include "ampi/UACAuthAPI.h"
 
 #include <sys/time.h>
 
@@ -42,121 +38,6 @@
 using std::map;
 using std::string;
 
-struct SIPRegistrationInfo {
-  string domain;
-  string user;
-  string name;
-  string auth_user;
-  string pwd;
-  string proxy;
-  string contact;
-
-  SIPRegistrationInfo(const string& domain,
-		      const string& user,
-		      const string& name,
-		      const string& auth_user,
-		      const string& pwd,
-		      const string& proxy,
-		      const string& contact)
-    : domain(domain),user(user),name(name),
-    auth_user(auth_user),pwd(pwd),proxy(proxy),contact(contact)
-  { }
-};
-
-class SIPRegistration : public AmSipDialogEventHandler,
-			public DialogControl,
-			public CredentialHolder
-	
-{
-	
-  AmSipDialog dlg;
-  UACAuthCred cred;
-
-  SIPRegistrationInfo info;
-
-  // session to post events to 
-  string sess_link;      
-
-  AmSessionEventHandler* seh;
-
-  AmSipRequest req;
-
-  ContactInfo server_contact;
-  ContactInfo local_contact;
-
-  time_t reg_begin;	
-  unsigned int reg_expires;
-  time_t reg_send_begin; 
-
- public:
-  SIPRegistration(const string& handle,
-		  const SIPRegistrationInfo& info,
-		  const string& sess_link);
-  ~SIPRegistration();
-
-  void setSessionEventHandler(AmSessionEventHandler* new_seh);
-
-  void doRegistration();
-  void doUnregister();
-	
-  inline bool timeToReregister(time_t now_sec);
-  inline bool registerExpired(time_t now_sec);
-  void onRegisterExpired();
-  void onRegisterSendTimeout();
-
-  inline bool registerSendTimeout(time_t now_sec);
-
-  void onSendRequest(const string& method,
-		     const string& content_type,
-		     const string& body,
-		     string& hdrs,
-		     int flags,
-		     unsigned int cseq);
-	
-  void onSendReply(const AmSipRequest& req,
-		   unsigned int  code,
-		   const string& reason,
-		   const string& content_type,
-		   const string& body,
-		   string& hdrs,
-		   int flags);
-
-  // DialogControl if
-  AmSipDialog* getDlg() { return &dlg; }
-  // CredentialHolder	
-  UACAuthCred* getCredentials() { return &cred; }
-
-  void onSipReply(const AmSipReply& reply, int old_dlg_status, const string& trans_method);
-  void onSipRequest(const AmSipRequest& req) {}
-  void onInvite2xx(const AmSipReply&) {}
-  void onNoAck(unsigned int) {}
-  void onNoPrack(const AmSipRequest &, const AmSipReply &) {}
-  void onInvite1xxRel(const AmSipReply &){}
-  void onPrack2xx(const AmSipReply &){}
-  void onFailure(AmSipDialogEventHandler::FailureCause cause, 
-      const AmSipRequest*, const AmSipReply*){}
-
-  /** is this registration registered? */
-  bool active; 
-  /** should this registration be removed from container? */
-  bool remove;
-  /** are we waiting for the response to a register? */
-  bool waiting_result;
-
-  enum RegistrationState {
-    RegisterPending = 0,
-    RegisterActive,
-    RegisterExpired
-  };
-  /** return the state of the registration */
-  RegistrationState getState(); 
-  /** return the expires left for the registration */
-  unsigned int getExpiresLeft(); 
-
-  SIPRegistrationInfo& getInfo() { return info; }
-  const string& getEventSink() { return sess_link; }
-};
-
 struct SIPNewRegistrationEvent;
 class SIPRemoveRegistrationEvent;
 
@@ -198,7 +79,8 @@ class SIPRegistrarClient  : public AmThread,
   void invoke(const string& method, 
 	      const AmArg& args, AmArg& ret);
 	
-  bool onSipReply(const AmSipReply& rep, int old_dlg_status, const string& trans_method);
+  bool onSipReply(const AmSipReply& rep, int old_dlg_status,
+		  const string& trans_method);
   int onLoad();
 	
   void run();
diff --git a/core/AmSipRegistration.cpp b/core/AmSipRegistration.cpp
new file mode 100644
index 0000000..367e807
--- /dev/null
+++ b/core/AmSipRegistration.cpp
@@ -0,0 +1,278 @@
+#include "AmSipRegistration.h"
+#include "AmSession.h"
+#include "AmSessionContainer.h"
+SIPRegistration::SIPRegistration(const string& handle,
+				 const SIPRegistrationInfo& info,
+				 const string& sess_link) 
+  : info(info),
+    dlg(this),
+    cred(info.domain, info.auth_user, info.pwd),
+    active(false),
+    reg_begin(0),
+    reg_expires(0),
+    remove(false),
+    sess_link(sess_link),
+    reg_send_begin(0),
+    waiting_result(false),
+    seh(NULL)
+{
+  req.cmd      = "sems";
+  req.user     = info.user;
+  req.method   = "REGISTER";
+  req.r_uri    = "sip:"+info.domain;
+  req.from     = info.name+" <sip:"+info.user+"@"+info.domain+">";
+  req.from_uri = "sip:"+info.user+"@"+info.domain;
+  req.from_tag = handle;
+  req.to       = req.from;
+  req.to_tag   = "";
+  req.callid   = AmSession::getNewId(); 
+  //
+
+  // clear dlg.callid? ->reregister?
+  dlg.updateStatusFromLocalRequest(req);
+  dlg.cseq = 50;
+  if(!info.contact.empty()) {
+      dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<sip:";
+      dlg.contact_uri += info.contact + ">" + CRLF;
+  }
+}
+
+SIPRegistration::~SIPRegistration() {
+  setSessionEventHandler(NULL);
+}
+
+void SIPRegistration::setSessionEventHandler(AmSessionEventHandler* new_seh) {
+  if (seh)
+    delete seh;
+  seh = new_seh;
+}
+ 
+void SIPRegistration::doRegistration() 
+{
+    waiting_result = true;
+    req.to_tag     = "";
+    dlg.remote_tag = "";
+    req.r_uri    = "sip:"+info.domain;
+    dlg.remote_uri = req.r_uri;
+    
+    // set outbound proxy as next hop 
+    if (!info.proxy.empty()) {
+	dlg.outbound_proxy = info.proxy;
+    } else if (!AmConfig::OutboundProxy.empty()) {
+	dlg.outbound_proxy = AmConfig::OutboundProxy;
+    }
+
+    if(!info.contact.empty()) {
+      dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<"
+        + info.contact + ">" + CRLF;
+    }
+    
+    if (dlg.sendRequest(req.method, "", "", "Expires: 3600\n") < 0)
+      ERROR("failed to send registration.\n");
+    
+    // save TS
+    struct timeval now;
+    gettimeofday(&now, NULL);
+    reg_send_begin  = now.tv_sec;
+}
+
+void SIPRegistration::doUnregister() 
+{
+    waiting_result = true;
+    req.to_tag     = "";
+    dlg.remote_tag = "";
+    req.r_uri      = "sip:"+info.domain;
+    dlg.remote_uri = req.r_uri;
+    
+    // set outbound proxy as next hop 
+    if (!info.proxy.empty()) {
+	dlg.outbound_proxy = info.proxy;
+    } else if (!AmConfig::OutboundProxy.empty()) 
+	dlg.outbound_proxy = AmConfig::OutboundProxy;
+    //else 
+    //    dlg.outbound_proxy = "";
+    if(!info.contact.empty()) {
+        dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<";
+        dlg.contact_uri += info.contact + ">" + CRLF;
+    }
+    
+    if (dlg.sendRequest(req.method, "", "", "Expires: 0\n") < 0)
+      ERROR("failed to send deregistration.\n");
+
+    // save TS
+    struct timeval now;
+    gettimeofday(&now, NULL);
+    reg_send_begin  = now.tv_sec;
+}
+
+void SIPRegistration::onSendRequest(const string& method,
+				    const string& content_type,
+				    const string& body,
+				    string& hdrs,
+				    int flags,
+				    unsigned int cseq) {
+  if (seh)
+    seh->onSendRequest(method, content_type, body,
+		       hdrs,flags,cseq);
+}
+	
+void SIPRegistration::onSendReply(const AmSipRequest& req,
+				  unsigned int  code,
+				  const string& reason,
+				  const string& content_type,
+				  const string& body,
+				  string& hdrs,
+				  int flags) {
+  if (seh)
+    seh->onSendReply(req,code,reason,
+		     content_type,body,hdrs,flags);
+}
+
+SIPRegistration::RegistrationState SIPRegistration::getState() {
+  if (active) 
+    return RegisterActive;
+  if (waiting_result)
+    return RegisterPending;
+	
+  return RegisterExpired;
+}
+
+unsigned int SIPRegistration::getExpiresLeft() {
+  struct timeval now;
+  gettimeofday(&now, NULL);
+	
+  int diff = reg_begin + reg_expires  - now.tv_sec;
+  if (diff < 0) 
+    return 0;
+  else 
+    return diff;
+}
+	
+void SIPRegistration::onRegisterExpired() {
+  if (sess_link.length()) {
+    AmSessionContainer::instance()->postEvent(sess_link,
+					      new SIPRegistrationEvent(SIPRegistrationEvent::RegisterTimeout,
+								       req.from_tag));
+  }
+  DBG("Registration '%s' expired.\n", (info.user+"@"+info.domain).c_str());
+  active = false;
+  remove = true;
+}
+
+void SIPRegistration::onRegisterSendTimeout() {
+  if (sess_link.length()) {
+    AmSessionContainer::instance()->
+      postEvent(sess_link,
+		new SIPRegistrationEvent(SIPRegistrationEvent::RegisterSendTimeout,
+					 req.from_tag));
+  }
+  DBG("Registration '%s' REGISTER request timeout.\n", 
+      (info.user+"@"+info.domain).c_str());
+  active = false;
+  remove = true;
+}
+
+
+bool SIPRegistration::registerSendTimeout(time_t now_sec) {
+  return now_sec > reg_send_begin + REGISTER_SEND_TIMEOUT;
+}
+
+bool SIPRegistration::timeToReregister(time_t now_sec) {
+  //   	if (active) 
+  //   		DBG("compare %lu with %lu\n",(reg_begin+reg_expires), (unsigned long)now_sec);
+  return (((unsigned long)reg_begin+ reg_expires/2) < (unsigned long)now_sec);	
+}
+
+bool SIPRegistration::registerExpired(time_t now_sec) {
+  return ((reg_begin+reg_expires) < (unsigned int)now_sec);	
+}
+
+void SIPRegistration::onSipReply(const AmSipReply& reply, int old_dlg_status, const string& trans_method)
+{
+  if ((seh!=NULL) && seh->onSipReply(reply, old_dlg_status, trans_method))
+    return;
+
+  waiting_result = false;
+
+  if ((reply.code>=200)&&(reply.code<300)) {
+    DBG("positive reply to REGISTER!\n");
+    size_t end  = 0;
+    string local_contact_hdr = dlg.getContactHdr();
+    local_contact.parse_contact(local_contact_hdr, (size_t)0, end);
+    local_contact.dump();
+
+    string contacts = reply.contact;
+    if (contacts.empty()) 
+      contacts = getHeader(reply.hdrs, "Contact", "m", true);
+    bool found = false;
+
+    if (!contacts.length()) {
+      DBG("received positive reply to de-Register \n");
+      active = false;
+      remove = true;
+    } else {
+      end = 0;
+      while (!found) {
+	if (contacts.length() == end)
+	  break;
+
+	if (!server_contact.parse_contact(contacts, end, end)) {
+	  ERROR("while parsing contact\n");
+	  break;
+	}
+	server_contact.dump();
+				
+	if (server_contact.isEqual(local_contact)) {
+	  DBG("contact found\n");
+	  found = active = true;
+	  //bool str2i(const string& str, unsigned int& result);
+					
+	  if (str2i(server_contact.params["expires"], reg_expires)) {
+	    ERROR("could not extract expires value.\n");
+	    reg_expires = 500;
+	  }
+	  DBG("got an expires of %d\n", reg_expires);
+	  // save TS
+	  struct timeval now;
+	  gettimeofday(&now, NULL);
+	  reg_begin = now.tv_sec;
+
+	  if (sess_link.length()) {
+	    DBG("posting SIPRegistrationEvent to '%s'\n", sess_link.c_str());
+	    AmSessionContainer::instance()->
+	      postEvent(sess_link,
+			new SIPRegistrationEvent(SIPRegistrationEvent::RegisterSuccess,
+						 req.from_tag,
+						 reply.code, reply.reason));
+	  }
+	  break;
+	}
+      }
+    }
+    if (!found) {
+      if (sess_link.length()) {
+	AmSessionContainer::instance()->
+	  postEvent(sess_link,
+		    new SIPRegistrationEvent(SIPRegistrationEvent::RegisterNoContact,
+					     req.from_tag,
+					     reply.code, reply.reason));
+      }
+      DBG("no matching Contact - deregistered.\n");
+      active = false;
+      remove = true;
+    }
+		
+  } else if (reply.code >= 300) {
+    DBG("Registration failed.\n");
+    if (sess_link.length()) {
+      AmSessionContainer::instance()->
+	postEvent(sess_link,
+		  new SIPRegistrationEvent(SIPRegistrationEvent::RegisterFailed,
+					   req.from_tag,
+					   reply.code, reply.reason));
+    }
+    active = false;
+    remove = true;		
+  }
+}
+
diff --git a/core/AmSipRegistration.h b/core/AmSipRegistration.h
new file mode 100644
index 0000000..dddbcc5
--- /dev/null
+++ b/core/AmSipRegistration.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2006 iptego GmbH
+ * Copyright (C) 2011 Stefan Sayer
+ *
+ * This file is part of SEMS, a free SIP media server.
+ *
+ * SEMS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version. This program is released under
+ * the GPL with the additional exemption that compiling, linking,
+ * and/or using OpenSSL is allowed.
+ *
+ * For a license to use the SEMS software under conditions
+ * other than those described here, or to purchase support for this
+ * software, please contact iptel.org by e-mail at the following addresses:
+ *    info@iptel.org
+ *
+ * SEMS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _AmSipRegistration_h_
+#define _AmSipRegistration_h_
+#include <string>
+using std::string;
+
+#include "ampi/SIPRegistrarClientAPI.h"
+#include "ampi/UACAuthAPI.h"
+#include "AmUriParser.h"
+#include "AmSessionEventHandler.h"
+
+#define REGISTER_SEND_TIMEOUT 60 
+
+struct SIPRegistrationInfo {
+  string domain;
+  string user;
+  string name;
+  string auth_user;
+  string pwd;
+  string proxy;
+  string contact;
+
+  SIPRegistrationInfo(const string& domain,
+		      const string& user,
+		      const string& name,
+		      const string& auth_user,
+		      const string& pwd,
+		      const string& proxy,
+		      const string& contact)
+    : domain(domain),user(user),name(name),
+    auth_user(auth_user),pwd(pwd),proxy(proxy),contact(contact)
+  { }
+};
+
+class SIPRegistration : public AmSipDialogEventHandler,
+			public DialogControl,
+			public CredentialHolder
+	
+{
+	
+  AmSipDialog dlg;
+  UACAuthCred cred;
+
+  SIPRegistrationInfo info;
+
+  // session to post events to 
+  string sess_link;      
+
+  AmSessionEventHandler* seh;
+
+  AmSipRequest req;
+
+  AmUriParser server_contact;
+  AmUriParser local_contact;
+
+  time_t reg_begin;	
+  unsigned int reg_expires;
+  time_t reg_send_begin; 
+
+ public:
+  SIPRegistration(const string& handle,
+		  const SIPRegistrationInfo& info,
+		  const string& sess_link);
+  ~SIPRegistration();
+
+  void setSessionEventHandler(AmSessionEventHandler* new_seh);
+
+  void doRegistration();
+  void doUnregister();
+	
+  bool timeToReregister(time_t now_sec);
+  bool registerExpired(time_t now_sec);
+  void onRegisterExpired();
+  void onRegisterSendTimeout();
+
+  bool registerSendTimeout(time_t now_sec);
+
+  void onSendRequest(const string& method,
+		     const string& content_type,
+		     const string& body,
+		     string& hdrs,
+		     int flags,
+		     unsigned int cseq);
+	
+  void onSendReply(const AmSipRequest& req,
+		   unsigned int  code,
+		   const string& reason,
+		   const string& content_type,
+		   const string& body,
+		   string& hdrs,
+		   int flags);
+
+  // DialogControl if
+  AmSipDialog* getDlg() { return &dlg; }
+  // CredentialHolder	
+  UACAuthCred* getCredentials() { return &cred; }
+
+  void onSipReply(const AmSipReply& reply, int old_dlg_status, const string& trans_method);
+  void onSipRequest(const AmSipRequest& req) {}
+  void onInvite2xx(const AmSipReply&) {}
+  void onNoAck(unsigned int) {}
+  void onNoPrack(const AmSipRequest &, const AmSipReply &) {}
+  void onInvite1xxRel(const AmSipReply &){}
+  void onPrack2xx(const AmSipReply &){}
+  void onFailure(AmSipDialogEventHandler::FailureCause cause, 
+      const AmSipRequest*, const AmSipReply*){}
+
+  /** is this registration registered? */
+  bool active; 
+  /** should this registration be removed from container? */
+  bool remove;
+  /** are we waiting for the response to a register? */
+  bool waiting_result;
+
+  enum RegistrationState {
+    RegisterPending = 0,
+    RegisterActive,
+    RegisterExpired
+  };
+  /** return the state of the registration */
+  RegistrationState getState(); 
+  /** return the expires left for the registration */
+  unsigned int getExpiresLeft(); 
+
+  SIPRegistrationInfo& getInfo() { return info; }
+  const string& getEventSink() { return sess_link; }
+};
+
+
+
+#endif
-- 
1.7.10.4

