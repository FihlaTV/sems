From 3ac923fcf90a9e36c60fbac41d3bcae2434df1f4 Mon Sep 17 00:00:00 2001
From: Stefan Sayer <stefan.sayer@googlemail.com>
Date: Wed, 4 May 2011 17:27:09 +0200
Subject: [PATCH] renamed SIPRegistration -> AmSIPRegistration

---
 apps/registrar_client/SIPRegistrarClient.cpp |   50 ++++----
 apps/registrar_client/SIPRegistrarClient.h   |   12 +-
 core/AmSipRegistration.cpp                   |  175 +++++++++++++++-----------
 core/AmSipRegistration.h                     |   15 +--
 4 files changed, 140 insertions(+), 112 deletions(-)

diff --git a/apps/registrar_client/SIPRegistrarClient.cpp b/apps/registrar_client/SIPRegistrarClient.cpp
index b19f162..f9c69c1 100644
--- a/apps/registrar_client/SIPRegistrarClient.cpp
+++ b/apps/registrar_client/SIPRegistrarClient.cpp
@@ -99,11 +99,11 @@ void SIPRegistrarClient::checkTimeouts() {
   reg_mut.lock();
   vector<string> remove_regs;
 
-  for (map<string, SIPRegistration*>::iterator it = registrations.begin();
+  for (map<string, AmSIPRegistration*>::iterator it = registrations.begin();
        it != registrations.end(); it++) {
     if (it->second->active) {
       if (it->second->registerExpired(now.tv_sec)) {
-	SIPRegistration* reg = it->second;
+	AmSIPRegistration* reg = it->second;
 	reg->onRegisterExpired();
       } else if (!it->second->waiting_result && 
 		 it->second->timeToReregister(now.tv_sec)) {
@@ -113,14 +113,14 @@ void SIPRegistrarClient::checkTimeouts() {
       remove_regs.push_back(it->first);
     } else if (it->second->waiting_result && 
 	       it->second->registerSendTimeout(now.tv_sec)) {
-      SIPRegistration* reg = it->second;
+      AmSIPRegistration* reg = it->second;
       reg->onRegisterSendTimeout();
     }
   }
   for (vector<string>::iterator it = remove_regs.begin(); 
        it != remove_regs.end(); it++) {
     DBG("removing registration\n");
-    SIPRegistration* reg = registrations[*it];
+    AmSIPRegistration* reg = registrations[*it];
     registrations.erase(*it);
     if (reg)
       delete reg;
@@ -137,7 +137,7 @@ int SIPRegistrarClient::onLoad() {
 void SIPRegistrarClient::onServerShutdown() {
   // TODO: properly wait until unregistered, with timeout
   DBG("shutdown SIP registrar client: deregistering\n");
-  for (std::map<std::string, SIPRegistration*>::iterator it=
+  for (std::map<std::string, AmSIPRegistration*>::iterator it=
 	 registrations.begin(); it != registrations.end(); it++) {
     it->second->doUnregister();
     AmEventDispatcher::instance()->delEventQueue(it->first);
@@ -184,7 +184,7 @@ void SIPRegistrarClient::process(AmEvent* ev)
 }
 
 void SIPRegistrarClient::onSipReplyEvent(AmSipReplyEvent* ev) {
-  SIPRegistration* reg = get_reg(ev->reply.local_tag);
+  AmSIPRegistration* reg = get_reg(ev->reply.local_tag);
   if (reg != NULL) {
       reg->getDlg()->updateStatus(ev->reply);//onSipReply(ev->reply);
   }
@@ -192,8 +192,8 @@ void SIPRegistrarClient::onSipReplyEvent(AmSipReplyEvent* ev) {
 
 void SIPRegistrarClient::onNewRegistration(SIPNewRegistrationEvent* new_reg) {
 
-  SIPRegistration* reg = new SIPRegistration(new_reg->handle, new_reg->info, 
-					     new_reg->sess_link);
+  AmSIPRegistration* reg = new AmSIPRegistration(new_reg->handle, new_reg->info, 
+						 new_reg->sess_link);
   
   if (uac_auth_i != NULL) {
     DBG("enabling UAC Auth for new registration.\n");
@@ -224,7 +224,7 @@ void SIPRegistrarClient::onNewRegistration(SIPNewRegistrationEvent* new_reg) {
 }
 
 void SIPRegistrarClient::onRemoveRegistration(SIPRemoveRegistrationEvent* new_reg) {
-  SIPRegistration* reg = get_reg(new_reg->handle);
+  AmSIPRegistration* reg = get_reg(new_reg->handle);
   if (reg)
     reg->doUnregister();
 }
@@ -247,13 +247,13 @@ bool SIPRegistrarClient::hasRegistration(const string& handle) {
   return get_reg(handle) != NULL;
 }
 
-SIPRegistration* SIPRegistrarClient::
+AmSIPRegistration* SIPRegistrarClient::
 get_reg(const string& reg_id) 
 {
   DBG("get registration '%s'\n", reg_id.c_str());
-  SIPRegistration* res = NULL;
+  AmSIPRegistration* res = NULL;
   reg_mut.lock();
-  map<string, SIPRegistration*>::iterator it = 
+  map<string, AmSIPRegistration*>::iterator it = 
     registrations.find(reg_id);
   if (it!=registrations.end())
     res = it->second;
@@ -262,12 +262,12 @@ get_reg(const string& reg_id)
   return res;
 }
 
-SIPRegistration* SIPRegistrarClient::
+AmSIPRegistration* SIPRegistrarClient::
 get_reg_unsafe(const string& reg_id) 
 {
   //	DBG("get registration_unsafe '%s'\n", reg_id.c_str());
-  SIPRegistration* res = NULL;
-  map<string, SIPRegistration*>::iterator it = 
+  AmSIPRegistration* res = NULL;
+  map<string, AmSIPRegistration*>::iterator it = 
     registrations.find(reg_id);
   if (it!=registrations.end())
     res = it->second;
@@ -275,19 +275,19 @@ get_reg_unsafe(const string& reg_id)
   return res;
 }
 
-SIPRegistration* SIPRegistrarClient::
+AmSIPRegistration* SIPRegistrarClient::
 remove_reg(const string& reg_id) {
   reg_mut.lock();
-  SIPRegistration* reg = remove_reg_unsafe(reg_id);
+  AmSIPRegistration* reg = remove_reg_unsafe(reg_id);
   reg_mut.unlock();
   return reg;
 }
 
-SIPRegistration* SIPRegistrarClient::
+AmSIPRegistration* SIPRegistrarClient::
 remove_reg_unsafe(const string& reg_id) {
   DBG("removing registration '%s'\n", reg_id.c_str());
-  SIPRegistration* reg = NULL;
-  map<string, SIPRegistration*>::iterator it = 
+  AmSIPRegistration* reg = NULL;
+  map<string, AmSIPRegistration*>::iterator it = 
     registrations.find(reg_id);
   if (it!=registrations.end()) {
     reg = it->second;
@@ -300,12 +300,12 @@ remove_reg_unsafe(const string& reg_id) {
 }
 
 void SIPRegistrarClient::
-add_reg(const string& reg_id, SIPRegistration* new_reg) 
+add_reg(const string& reg_id, AmSIPRegistration* new_reg) 
 {
   DBG("adding registration '%s'  (this = %ld)\n", reg_id.c_str(), (long)this);
-  SIPRegistration* reg = NULL;
+  AmSIPRegistration* reg = NULL;
   reg_mut.lock();
-  map<string, SIPRegistration*>::iterator it = 
+  map<string, AmSIPRegistration*>::iterator it = 
     registrations.find(reg_id);
   if (it!=registrations.end()) {
     reg = it->second;
@@ -353,7 +353,7 @@ bool SIPRegistrarClient::getRegistrationState(const string& handle,
   bool res = false;
   reg_mut.lock();
 
-  SIPRegistration* reg = get_reg_unsafe(handle);
+  AmSIPRegistration* reg = get_reg_unsafe(handle);
   if (reg) {
     res = true;
     state = reg->getState();
@@ -367,7 +367,7 @@ bool SIPRegistrarClient::getRegistrationState(const string& handle,
 void SIPRegistrarClient::listRegistrations(AmArg& res) {
   reg_mut.lock();
 
-  for (map<string, SIPRegistration*>::iterator it = 
+  for (map<string, AmSIPRegistration*>::iterator it = 
 	 registrations.begin(); it != registrations.end(); it++) {
     AmArg r;
     r["handle"] = it->first;
diff --git a/apps/registrar_client/SIPRegistrarClient.h b/apps/registrar_client/SIPRegistrarClient.h
index d054565..1137b52 100644
--- a/apps/registrar_client/SIPRegistrarClient.h
+++ b/apps/registrar_client/SIPRegistrarClient.h
@@ -49,14 +49,14 @@ class SIPRegistrarClient  : public AmThread,
 {
   // registrations container
   AmMutex                       reg_mut;
-  std::map<std::string, SIPRegistration*> registrations;
+  std::map<std::string, AmSIPRegistration*> registrations;
 
   void add_reg(const string& reg_id, 
-	       SIPRegistration* new_reg);
-  SIPRegistration* remove_reg(const string& reg_id);
-  SIPRegistration* remove_reg_unsafe(const string& reg_id);
-  SIPRegistration* get_reg(const string& reg_id);
-  SIPRegistration* get_reg_unsafe(const string& reg_id);
+	       AmSIPRegistration* new_reg);
+  AmSIPRegistration* remove_reg(const string& reg_id);
+  AmSIPRegistration* remove_reg_unsafe(const string& reg_id);
+  AmSIPRegistration* get_reg(const string& reg_id);
+  AmSIPRegistration* get_reg_unsafe(const string& reg_id);
 
   void onSipReplyEvent(AmSipReplyEvent* ev);	
   void onNewRegistration(SIPNewRegistrationEvent* new_reg);
diff --git a/core/AmSipRegistration.cpp b/core/AmSipRegistration.cpp
index 367e807..4cad029 100644
--- a/core/AmSipRegistration.cpp
+++ b/core/AmSipRegistration.cpp
@@ -1,9 +1,37 @@
+/*
+ * Copyright (C) 2006 iptego GmbH
+ * Copyright (C) 2011 Stefan Sayer
+ *
+ * This file is part of SEMS, a free SIP media server.
+ *
+ * SEMS is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version. This program is released under
+ * the GPL with the additional exemption that compiling, linking,
+ * and/or using OpenSSL is allowed.
+ *
+ * For a license to use the SEMS software under conditions
+ * other than those described here, or to purchase support for this
+ * software, please contact iptel.org by e-mail at the following addresses:
+ *    info@iptel.org
+ *
+ * SEMS is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
 #include "AmSipRegistration.h"
 #include "AmSession.h"
 #include "AmSessionContainer.h"
-SIPRegistration::SIPRegistration(const string& handle,
-				 const SIPRegistrationInfo& info,
-				 const string& sess_link) 
+AmSIPRegistration::AmSIPRegistration(const string& handle,
+				     const SIPRegistrationInfo& info,
+				     const string& sess_link) 
   : info(info),
     dlg(this),
     cred(info.domain, info.auth_user, info.pwd),
@@ -32,103 +60,103 @@ SIPRegistration::SIPRegistration(const string& handle,
   dlg.updateStatusFromLocalRequest(req);
   dlg.cseq = 50;
   if(!info.contact.empty()) {
-      dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<sip:";
-      dlg.contact_uri += info.contact + ">" + CRLF;
+    dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<sip:";
+    dlg.contact_uri += info.contact + ">" + CRLF;
   }
 }
 
-SIPRegistration::~SIPRegistration() {
+AmSIPRegistration::~AmSIPRegistration() {
   setSessionEventHandler(NULL);
 }
 
-void SIPRegistration::setSessionEventHandler(AmSessionEventHandler* new_seh) {
+void AmSIPRegistration::setSessionEventHandler(AmSessionEventHandler* new_seh) {
   if (seh)
     delete seh;
   seh = new_seh;
 }
  
-void SIPRegistration::doRegistration() 
+void AmSIPRegistration::doRegistration() 
 {
-    waiting_result = true;
-    req.to_tag     = "";
-    dlg.remote_tag = "";
-    req.r_uri    = "sip:"+info.domain;
-    dlg.remote_uri = req.r_uri;
+  waiting_result = true;
+  req.to_tag     = "";
+  dlg.remote_tag = "";
+  req.r_uri    = "sip:"+info.domain;
+  dlg.remote_uri = req.r_uri;
     
-    // set outbound proxy as next hop 
-    if (!info.proxy.empty()) {
-	dlg.outbound_proxy = info.proxy;
-    } else if (!AmConfig::OutboundProxy.empty()) {
-	dlg.outbound_proxy = AmConfig::OutboundProxy;
-    }
+  // set outbound proxy as next hop 
+  if (!info.proxy.empty()) {
+    dlg.outbound_proxy = info.proxy;
+  } else if (!AmConfig::OutboundProxy.empty()) {
+    dlg.outbound_proxy = AmConfig::OutboundProxy;
+  }
 
-    if(!info.contact.empty()) {
-      dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<"
-        + info.contact + ">" + CRLF;
-    }
+  if(!info.contact.empty()) {
+    dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<"
+      + info.contact + ">" + CRLF;
+  }
     
-    if (dlg.sendRequest(req.method, "", "", "Expires: 3600\n") < 0)
-      ERROR("failed to send registration.\n");
+  if (dlg.sendRequest(req.method, "", "", "Expires: 3600\n") < 0)
+    ERROR("failed to send registration.\n");
     
-    // save TS
-    struct timeval now;
-    gettimeofday(&now, NULL);
-    reg_send_begin  = now.tv_sec;
+  // save TS
+  struct timeval now;
+  gettimeofday(&now, NULL);
+  reg_send_begin  = now.tv_sec;
 }
 
-void SIPRegistration::doUnregister() 
+void AmSIPRegistration::doUnregister() 
 {
-    waiting_result = true;
-    req.to_tag     = "";
-    dlg.remote_tag = "";
-    req.r_uri      = "sip:"+info.domain;
-    dlg.remote_uri = req.r_uri;
+  waiting_result = true;
+  req.to_tag     = "";
+  dlg.remote_tag = "";
+  req.r_uri      = "sip:"+info.domain;
+  dlg.remote_uri = req.r_uri;
     
-    // set outbound proxy as next hop 
-    if (!info.proxy.empty()) {
-	dlg.outbound_proxy = info.proxy;
-    } else if (!AmConfig::OutboundProxy.empty()) 
-	dlg.outbound_proxy = AmConfig::OutboundProxy;
-    //else 
-    //    dlg.outbound_proxy = "";
-    if(!info.contact.empty()) {
-        dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<";
-        dlg.contact_uri += info.contact + ">" + CRLF;
-    }
+  // set outbound proxy as next hop 
+  if (!info.proxy.empty()) {
+    dlg.outbound_proxy = info.proxy;
+  } else if (!AmConfig::OutboundProxy.empty()) 
+    dlg.outbound_proxy = AmConfig::OutboundProxy;
+  //else 
+  //    dlg.outbound_proxy = "";
+  if(!info.contact.empty()) {
+    dlg.contact_uri = SIP_HDR_COLSP(SIP_HDR_CONTACT) "<";
+    dlg.contact_uri += info.contact + ">" + CRLF;
+  }
     
-    if (dlg.sendRequest(req.method, "", "", "Expires: 0\n") < 0)
-      ERROR("failed to send deregistration.\n");
+  if (dlg.sendRequest(req.method, "", "", "Expires: 0\n") < 0)
+    ERROR("failed to send deregistration.\n");
 
-    // save TS
-    struct timeval now;
-    gettimeofday(&now, NULL);
-    reg_send_begin  = now.tv_sec;
+  // save TS
+  struct timeval now;
+  gettimeofday(&now, NULL);
+  reg_send_begin  = now.tv_sec;
 }
 
-void SIPRegistration::onSendRequest(const string& method,
-				    const string& content_type,
-				    const string& body,
-				    string& hdrs,
-				    int flags,
-				    unsigned int cseq) {
+void AmSIPRegistration::onSendRequest(const string& method,
+				      const string& content_type,
+				      const string& body,
+				      string& hdrs,
+				      int flags,
+				      unsigned int cseq) {
   if (seh)
     seh->onSendRequest(method, content_type, body,
 		       hdrs,flags,cseq);
 }
 	
-void SIPRegistration::onSendReply(const AmSipRequest& req,
-				  unsigned int  code,
-				  const string& reason,
-				  const string& content_type,
-				  const string& body,
-				  string& hdrs,
-				  int flags) {
+void AmSIPRegistration::onSendReply(const AmSipRequest& req,
+				    unsigned int  code,
+				    const string& reason,
+				    const string& content_type,
+				    const string& body,
+				    string& hdrs,
+				    int flags) {
   if (seh)
     seh->onSendReply(req,code,reason,
 		     content_type,body,hdrs,flags);
 }
 
-SIPRegistration::RegistrationState SIPRegistration::getState() {
+AmSIPRegistration::RegistrationState AmSIPRegistration::getState() {
   if (active) 
     return RegisterActive;
   if (waiting_result)
@@ -137,7 +165,7 @@ SIPRegistration::RegistrationState SIPRegistration::getState() {
   return RegisterExpired;
 }
 
-unsigned int SIPRegistration::getExpiresLeft() {
+unsigned int AmSIPRegistration::getExpiresLeft() {
   struct timeval now;
   gettimeofday(&now, NULL);
 	
@@ -148,7 +176,7 @@ unsigned int SIPRegistration::getExpiresLeft() {
     return diff;
 }
 	
-void SIPRegistration::onRegisterExpired() {
+void AmSIPRegistration::onRegisterExpired() {
   if (sess_link.length()) {
     AmSessionContainer::instance()->postEvent(sess_link,
 					      new SIPRegistrationEvent(SIPRegistrationEvent::RegisterTimeout,
@@ -159,7 +187,7 @@ void SIPRegistration::onRegisterExpired() {
   remove = true;
 }
 
-void SIPRegistration::onRegisterSendTimeout() {
+void AmSIPRegistration::onRegisterSendTimeout() {
   if (sess_link.length()) {
     AmSessionContainer::instance()->
       postEvent(sess_link,
@@ -172,22 +200,21 @@ void SIPRegistration::onRegisterSendTimeout() {
   remove = true;
 }
 
-
-bool SIPRegistration::registerSendTimeout(time_t now_sec) {
+bool AmSIPRegistration::registerSendTimeout(time_t now_sec) {
   return now_sec > reg_send_begin + REGISTER_SEND_TIMEOUT;
 }
 
-bool SIPRegistration::timeToReregister(time_t now_sec) {
+bool AmSIPRegistration::timeToReregister(time_t now_sec) {
   //   	if (active) 
   //   		DBG("compare %lu with %lu\n",(reg_begin+reg_expires), (unsigned long)now_sec);
   return (((unsigned long)reg_begin+ reg_expires/2) < (unsigned long)now_sec);	
 }
 
-bool SIPRegistration::registerExpired(time_t now_sec) {
+bool AmSIPRegistration::registerExpired(time_t now_sec) {
   return ((reg_begin+reg_expires) < (unsigned int)now_sec);	
 }
 
-void SIPRegistration::onSipReply(const AmSipReply& reply, int old_dlg_status, const string& trans_method)
+void AmSIPRegistration::onSipReply(const AmSipReply& reply, int old_dlg_status, const string& trans_method)
 {
   if ((seh!=NULL) && seh->onSipReply(reply, old_dlg_status, trans_method))
     return;
diff --git a/core/AmSipRegistration.h b/core/AmSipRegistration.h
index dddbcc5..d4b14c3 100644
--- a/core/AmSipRegistration.h
+++ b/core/AmSipRegistration.h
@@ -59,9 +59,10 @@ struct SIPRegistrationInfo {
   { }
 };
 
-class SIPRegistration : public AmSipDialogEventHandler,
-			public DialogControl,
-			public CredentialHolder
+class AmSIPRegistration 
+: public AmSipDialogEventHandler,
+  public DialogControl,
+  public CredentialHolder
 	
 {
 	
@@ -85,10 +86,10 @@ class SIPRegistration : public AmSipDialogEventHandler,
   time_t reg_send_begin; 
 
  public:
-  SIPRegistration(const string& handle,
-		  const SIPRegistrationInfo& info,
-		  const string& sess_link);
-  ~SIPRegistration();
+  AmSIPRegistration(const string& handle,
+		    const SIPRegistrationInfo& info,
+		    const string& sess_link);
+  ~AmSIPRegistration();
 
   void setSessionEventHandler(AmSessionEventHandler* new_seh);
 
-- 
1.7.10.4

